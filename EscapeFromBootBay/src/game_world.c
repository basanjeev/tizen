/* This file has been automatically generated by geneet.py */
/*                      DO NOT MODIFY                      */

#include <limits.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <Eet.h>

#include "game_world.h"

struct _Target {
    const char * type;
    int x;
    int y;
    int w;
    int h;
};

struct _Block {
    const char * type;
    int x;
    int y;
    int w;
    int h;
    int mass;
    int relto;
};

struct _Object {
    const char * type;
    int x;
    int y;
    int w;
    int h;
    int above;
};

struct _Level {
    int level_num;
    const char * level_id;
    int cannon_pos_x;
    int cannon_pos_y;
    int ammo;
    int bg;
    int time_attack;
    Eina_List * blocks;
    Eina_List * targets;
    Eina_List * objects;
};

struct _World {
    Eina_List * levels;
    const char *__eet_filename;
};

static const char TARGET_ENTRY[] = "target";
static const char BLOCK_ENTRY[] = "block";
static const char OBJECT_ENTRY[] = "object";
static const char LEVEL_ENTRY[] = "level";
static const char WORLD_ENTRY[] = "world";

static Eet_Data_Descriptor *_target_descriptor = NULL;
static Eet_Data_Descriptor *_block_descriptor = NULL;
static Eet_Data_Descriptor *_object_descriptor = NULL;
static Eet_Data_Descriptor *_level_descriptor = NULL;
static Eet_Data_Descriptor *_world_descriptor = NULL;

static inline void
_target_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_target_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Target);
    _target_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_target_descriptor, Target, "type", type, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_target_descriptor, Target, "x", x, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_target_descriptor, Target, "y", y, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_target_descriptor, Target, "w", w, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_target_descriptor, Target, "h", h, EET_T_INT);
}

static inline void
_target_shutdown(void)
{
    if (!_target_descriptor) return;
    eet_data_descriptor_free(_target_descriptor);
    _target_descriptor = NULL;
}

Target *
target_new(const char * type, int x, int y, int w, int h)
{
    Target *target = calloc(1, sizeof(Target));

    if (!target)
       {
          fprintf(stderr, "ERROR: could not calloc Target\n");
          return NULL;
       }

    target->type = eina_stringshare_add(type);
    target->x = x;
    target->y = y;
    target->w = w;
    target->h = h;

    return target;
}

void
target_free(Target *target)
{
    eina_stringshare_del(target->type);
    free(target);
}

inline const char *
target_type_get(const Target *target)
{
    return target->type;
}

inline void
target_type_set(Target *target, const char *type)
{
    EINA_SAFETY_ON_NULL_RETURN(target);
    eina_stringshare_replace(&(target->type), type);
}

inline int
target_x_get(const Target *target)
{
    return target->x;
}

inline void
target_x_set(Target *target, int x)
{
    EINA_SAFETY_ON_NULL_RETURN(target);
    target->x = x;
}

inline int
target_y_get(const Target *target)
{
    return target->y;
}

inline void
target_y_set(Target *target, int y)
{
    EINA_SAFETY_ON_NULL_RETURN(target);
    target->y = y;
}

inline int
target_w_get(const Target *target)
{
    return target->w;
}

inline void
target_w_set(Target *target, int w)
{
    EINA_SAFETY_ON_NULL_RETURN(target);
    target->w = w;
}

inline int
target_h_get(const Target *target)
{
    return target->h;
}

inline void
target_h_set(Target *target, int h)
{
    EINA_SAFETY_ON_NULL_RETURN(target);
    target->h = h;
}


static inline void
_block_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_block_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Block);
    _block_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_block_descriptor, Block, "type", type, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_block_descriptor, Block, "x", x, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_block_descriptor, Block, "y", y, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_block_descriptor, Block, "w", w, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_block_descriptor, Block, "h", h, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_block_descriptor, Block, "mass", mass, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_block_descriptor, Block, "relto", relto, EET_T_INT);
}

static inline void
_block_shutdown(void)
{
    if (!_block_descriptor) return;
    eet_data_descriptor_free(_block_descriptor);
    _block_descriptor = NULL;
}

Block *
block_new(const char * type, int x, int y, int w, int h, int mass, int relto)
{
    Block *block = calloc(1, sizeof(Block));

    if (!block)
       {
          fprintf(stderr, "ERROR: could not calloc Block\n");
          return NULL;
       }

    block->type = eina_stringshare_add(type);
    block->x = x;
    block->y = y;
    block->w = w;
    block->h = h;
    block->mass = mass;
    block->relto = relto;

    return block;
}

void
block_free(Block *block)
{
    eina_stringshare_del(block->type);
    free(block);
}

inline const char *
block_type_get(const Block *block)
{
    return block->type;
}

inline void
block_type_set(Block *block, const char *type)
{
    EINA_SAFETY_ON_NULL_RETURN(block);
    eina_stringshare_replace(&(block->type), type);
}

inline int
block_x_get(const Block *block)
{
    return block->x;
}

inline void
block_x_set(Block *block, int x)
{
    EINA_SAFETY_ON_NULL_RETURN(block);
    block->x = x;
}

inline int
block_y_get(const Block *block)
{
    return block->y;
}

inline void
block_y_set(Block *block, int y)
{
    EINA_SAFETY_ON_NULL_RETURN(block);
    block->y = y;
}

inline int
block_w_get(const Block *block)
{
    return block->w;
}

inline void
block_w_set(Block *block, int w)
{
    EINA_SAFETY_ON_NULL_RETURN(block);
    block->w = w;
}

inline int
block_h_get(const Block *block)
{
    return block->h;
}

inline void
block_h_set(Block *block, int h)
{
    EINA_SAFETY_ON_NULL_RETURN(block);
    block->h = h;
}

inline int
block_mass_get(const Block *block)
{
    return block->mass;
}

inline void
block_mass_set(Block *block, int mass)
{
    EINA_SAFETY_ON_NULL_RETURN(block);
    block->mass = mass;
}

inline int
block_relto_get(const Block *block)
{
    return block->relto;
}

inline void
block_relto_set(Block *block, int relto)
{
    EINA_SAFETY_ON_NULL_RETURN(block);
    block->relto = relto;
}


static inline void
_object_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_object_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Object);
    _object_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_object_descriptor, Object, "type", type, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_object_descriptor, Object, "x", x, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_object_descriptor, Object, "y", y, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_object_descriptor, Object, "w", w, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_object_descriptor, Object, "h", h, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_object_descriptor, Object, "above", above, EET_T_INT);
}

static inline void
_object_shutdown(void)
{
    if (!_object_descriptor) return;
    eet_data_descriptor_free(_object_descriptor);
    _object_descriptor = NULL;
}

Object *
object_new(const char * type, int x, int y, int w, int h, int above)
{
    Object *object = calloc(1, sizeof(Object));

    if (!object)
       {
          fprintf(stderr, "ERROR: could not calloc Object\n");
          return NULL;
       }

    object->type = eina_stringshare_add(type);
    object->x = x;
    object->y = y;
    object->w = w;
    object->h = h;
    object->above = above;

    return object;
}

void
object_free(Object *object)
{
    eina_stringshare_del(object->type);
    free(object);
}

inline const char *
object_type_get(const Object *object)
{
    return object->type;
}

inline void
object_type_set(Object *object, const char *type)
{
    EINA_SAFETY_ON_NULL_RETURN(object);
    eina_stringshare_replace(&(object->type), type);
}

inline int
object_x_get(const Object *object)
{
    return object->x;
}

inline void
object_x_set(Object *object, int x)
{
    EINA_SAFETY_ON_NULL_RETURN(object);
    object->x = x;
}

inline int
object_y_get(const Object *object)
{
    return object->y;
}

inline void
object_y_set(Object *object, int y)
{
    EINA_SAFETY_ON_NULL_RETURN(object);
    object->y = y;
}

inline int
object_w_get(const Object *object)
{
    return object->w;
}

inline void
object_w_set(Object *object, int w)
{
    EINA_SAFETY_ON_NULL_RETURN(object);
    object->w = w;
}

inline int
object_h_get(const Object *object)
{
    return object->h;
}

inline void
object_h_set(Object *object, int h)
{
    EINA_SAFETY_ON_NULL_RETURN(object);
    object->h = h;
}

inline int
object_above_get(const Object *object)
{
    return object->above;
}

inline void
object_above_set(Object *object, int above)
{
    EINA_SAFETY_ON_NULL_RETURN(object);
    object->above = above;
}


static inline void
_level_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_level_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, Level);
    _level_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_BASIC(_level_descriptor, Level, "level_num", level_num, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_level_descriptor, Level, "level_id", level_id, EET_T_STRING);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_level_descriptor, Level, "cannon_pos_x", cannon_pos_x, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_level_descriptor, Level, "cannon_pos_y", cannon_pos_y, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_level_descriptor, Level, "ammo", ammo, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_level_descriptor, Level, "bg", bg, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_BASIC(_level_descriptor, Level, "time_attack", time_attack, EET_T_INT);
    EET_DATA_DESCRIPTOR_ADD_LIST(_level_descriptor, Level, "blocks", blocks, _block_descriptor);
    EET_DATA_DESCRIPTOR_ADD_LIST(_level_descriptor, Level, "targets", targets, _target_descriptor);
    EET_DATA_DESCRIPTOR_ADD_LIST(_level_descriptor, Level, "objects", objects, _object_descriptor);
}

static inline void
_level_shutdown(void)
{
    if (!_level_descriptor) return;
    eet_data_descriptor_free(_level_descriptor);
    _level_descriptor = NULL;
}

Level *
level_new(int level_num, const char * level_id, int cannon_pos_x, int cannon_pos_y, int ammo, int bg, int time_attack, Eina_List * blocks, Eina_List * targets, Eina_List * objects)
{
    Level *level = calloc(1, sizeof(Level));

    if (!level)
       {
          fprintf(stderr, "ERROR: could not calloc Level\n");
          return NULL;
       }

    level->level_num = level_num;
    level->level_id = eina_stringshare_add(level_id);
    level->cannon_pos_x = cannon_pos_x;
    level->cannon_pos_y = cannon_pos_y;
    level->ammo = ammo;
    level->bg = bg;
    level->time_attack = time_attack;
    level->blocks = blocks;
    level->targets = targets;
    level->objects = objects;

    return level;
}

void
level_free(Level *level)
{
    eina_stringshare_del(level->level_id);
    if (level->blocks)
       {
          Block *blocks_elem;
          EINA_LIST_FREE(level->blocks, blocks_elem)
             block_free(blocks_elem);
       }
    if (level->targets)
       {
          Target *targets_elem;
          EINA_LIST_FREE(level->targets, targets_elem)
             target_free(targets_elem);
       }
    if (level->objects)
       {
          Object *objects_elem;
          EINA_LIST_FREE(level->objects, objects_elem)
             object_free(objects_elem);
       }
    free(level);
}

inline int
level_level_num_get(const Level *level)
{
    return level->level_num;
}

inline void
level_level_num_set(Level *level, int level_num)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->level_num = level_num;
}

inline const char *
level_level_id_get(const Level *level)
{
    return level->level_id;
}

inline void
level_level_id_set(Level *level, const char *level_id)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    eina_stringshare_replace(&(level->level_id), level_id);
}

inline int
level_cannon_pos_x_get(const Level *level)
{
    return level->cannon_pos_x;
}

inline void
level_cannon_pos_x_set(Level *level, int cannon_pos_x)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->cannon_pos_x = cannon_pos_x;
}

inline int
level_cannon_pos_y_get(const Level *level)
{
    return level->cannon_pos_y;
}

inline void
level_cannon_pos_y_set(Level *level, int cannon_pos_y)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->cannon_pos_y = cannon_pos_y;
}

inline int
level_ammo_get(const Level *level)
{
    return level->ammo;
}

inline void
level_ammo_set(Level *level, int ammo)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->ammo = ammo;
}

inline int
level_bg_get(const Level *level)
{
    return level->bg;
}

inline void
level_bg_set(Level *level, int bg)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->bg = bg;
}

inline int
level_time_attack_get(const Level *level)
{
    return level->time_attack;
}

inline void
level_time_attack_set(Level *level, int time_attack)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->time_attack = time_attack;
}

inline void
level_blocks_add(Level *level, Block *block)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->blocks = eina_list_append(level->blocks, block);
}

inline void
level_blocks_del(Level *level, Block *block)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->blocks = eina_list_remove(level->blocks, block);
}

inline Block *
level_blocks_get(const Level *level, unsigned int nth)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, NULL);
    return eina_list_nth(level->blocks, nth);
}

inline unsigned int
level_blocks_count(const Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, 0);
    return eina_list_count(level->blocks);
}

void
level_blocks_list_clear(Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    Block *data;
    EINA_LIST_FREE(level->blocks, data) block_free(data);
}

inline Eina_List *
level_blocks_list_get(const Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, NULL);
    return level->blocks;
}

inline void
level_blocks_list_set(Level *level, Eina_List *list)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->blocks = list;
}

inline void
level_targets_add(Level *level, Target *target)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->targets = eina_list_append(level->targets, target);
}

inline void
level_targets_del(Level *level, Target *target)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->targets = eina_list_remove(level->targets, target);
}

inline Target *
level_targets_get(const Level *level, unsigned int nth)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, NULL);
    return eina_list_nth(level->targets, nth);
}

inline unsigned int
level_targets_count(const Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, 0);
    return eina_list_count(level->targets);
}

void
level_targets_list_clear(Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    Target *data;
    EINA_LIST_FREE(level->targets, data) target_free(data);
}

inline Eina_List *
level_targets_list_get(const Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, NULL);
    return level->targets;
}

inline void
level_targets_list_set(Level *level, Eina_List *list)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->targets = list;
}

inline void
level_objects_add(Level *level, Object *object)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->objects = eina_list_append(level->objects, object);
}

inline void
level_objects_del(Level *level, Object *object)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->objects = eina_list_remove(level->objects, object);
}

inline Object *
level_objects_get(const Level *level, unsigned int nth)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, NULL);
    return eina_list_nth(level->objects, nth);
}

inline unsigned int
level_objects_count(const Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, 0);
    return eina_list_count(level->objects);
}

void
level_objects_list_clear(Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    Object *data;
    EINA_LIST_FREE(level->objects, data) object_free(data);
}

inline Eina_List *
level_objects_list_get(const Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(level, NULL);
    return level->objects;
}

inline void
level_objects_list_set(Level *level, Eina_List *list)
{
    EINA_SAFETY_ON_NULL_RETURN(level);
    level->objects = list;
}


static inline void
_world_init(void)
{
    Eet_Data_Descriptor_Class eddc;

    if (_world_descriptor) return;

    EET_EINA_STREAM_DATA_DESCRIPTOR_CLASS_SET(&eddc, World);
    _world_descriptor = eet_data_descriptor_stream_new(&eddc);

    EET_DATA_DESCRIPTOR_ADD_LIST(_world_descriptor, World, "levels", levels, _level_descriptor);
}

static inline void
_world_shutdown(void)
{
    if (!_world_descriptor) return;
    eet_data_descriptor_free(_world_descriptor);
    _world_descriptor = NULL;
}

World *
world_new(Eina_List * levels)
{
    World *world = calloc(1, sizeof(World));

    if (!world)
       {
          fprintf(stderr, "ERROR: could not calloc World\n");
          return NULL;
       }

    world->levels = levels;

    return world;
}

void
world_free(World *world)
{
    if (world->levels)
       {
          Level *levels_elem;
          EINA_LIST_FREE(world->levels, levels_elem)
             level_free(levels_elem);
       }
    free(world);
}

inline void
world_levels_add(World *world, Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN(world);
    world->levels = eina_list_append(world->levels, level);
}

inline void
world_levels_del(World *world, Level *level)
{
    EINA_SAFETY_ON_NULL_RETURN(world);
    world->levels = eina_list_remove(world->levels, level);
}

inline Level *
world_levels_get(const World *world, unsigned int nth)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(world, NULL);
    return eina_list_nth(world->levels, nth);
}

inline unsigned int
world_levels_count(const World *world)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(world, 0);
    return eina_list_count(world->levels);
}

void
world_levels_list_clear(World *world)
{
    EINA_SAFETY_ON_NULL_RETURN(world);
    Level *data;
    EINA_LIST_FREE(world->levels, data) level_free(data);
}

inline Eina_List *
world_levels_list_get(const World *world)
{
    EINA_SAFETY_ON_NULL_RETURN_VAL(world, NULL);
    return world->levels;
}

inline void
world_levels_list_set(World *world, Eina_List *list)
{
    EINA_SAFETY_ON_NULL_RETURN(world);
    world->levels = list;
}

World *
world_load(const char *filename)
{
    World *world = NULL;
    Eet_File *ef = eet_open(filename, EET_FILE_MODE_READ);
    if (!ef)
      {
        fprintf(stderr, "ERROR: could not open '%s' for read\n", filename);
        return NULL;
      }

    world = eet_data_read(ef, _world_descriptor, WORLD_ENTRY);
    if (!world) goto end;
    world->__eet_filename = eina_stringshare_add(filename);

end:
    eet_close(ef);
    return world;
}

Eina_Bool
world_save(World *world, const char *filename)
{
    Eet_File *ef;
    Eina_Bool ret;

    if (filename) eina_stringshare_replace(&(world->__eet_filename), filename);
    else if (world->__eet_filename) filename = world->__eet_filename;
    else return EINA_FALSE;

    ef = eet_open(filename, EET_FILE_MODE_READ_WRITE);
    if (!ef)
       {
          fprintf(stderr, "ERROR: could not open '%s' for write\n", filename);
          return EINA_FALSE;
       }

    ret = !!eet_data_write(ef, _world_descriptor, WORLD_ENTRY, world, EINA_TRUE);
    eet_close(ef);

    return ret;
}

void
game_world_init(void)
{
    _target_init();
    _block_init();
    _object_init();
    _level_init();
    _world_init();
}

void
game_world_shutdown(void)
{
    _target_shutdown();
    _block_shutdown();
    _object_shutdown();
    _level_shutdown();
    _world_shutdown();
}

